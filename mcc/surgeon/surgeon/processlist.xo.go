// Package surgeon contains the types for schema 'public'.
package surgeon

import (
	"fmt"
	"sort"
)

// GENERATED BY XO. DO NOT EDIT.

// Process represents a row from '[custom process_list2]'.
type Process struct {
	Pid      int      // pid
	Usename  Name     // usename
	Datname  Name     // datname
	Client   Inet     // client_addr
	Duration Duration // duration
	Query    string   // query
	Waiting  string   // waiting
}

// IsActive returns true if the Process was active when extracted.
func (ps Process) IsActive() bool {
	return ps.Query != "Inactive"
}

// ProcessList represents a slice of Process.
type ProcessList struct {
	Processes []Process
	Inactive  bool
}

// Len returns the length of a ProcessList.
func (pl ProcessList) Len() int {
	return len(pl.Processes)
}

// Less returns whether a Process is less than another in a ProcessList.
func (pl ProcessList) Less(i, j int) bool {
	firstDuration := pl.Processes[i].Duration.Seconds()
	secondDuration := pl.Processes[j].Duration.Seconds()
	return firstDuration < secondDuration
}

// Swap exchanges two Processes in the ProcessList.
func (pl ProcessList) Swap(i, j int) {
	pl.Processes[i], pl.Processes[j] = pl.Processes[j], pl.Processes[i]
}

// String provides a string formatting to ProcessList, which depends on
// Inactive field value.
func (pl ProcessList) String() (output string) {
	output = fmt.Sprintf(
		" %5s %10s %19s %17s %13s %9s %s \n",
		"PID",
		"USER",
		"DB",
		"CLIENT",
		"DURATION",
		"WAITING",
		"QUERY",
	)
	sort.Sort(pl)
	for _, process := range pl.Processes {
		if pl.Inactive || process.IsActive() {
			output += fmt.Sprintf(
				" %5d %12s %20s %17s %10.2f %9s %s \n",
				process.Pid,
				process.Usename,
				process.Datname,
				process.Client.String(),
				process.Duration.Duration,
				process.Waiting,
				process.Query,
			)
		}
	}
	return
}

// GetProcessLists runs a custom query, returning results as ProcessList.
func GetProcessLists(db XODB, options map[string]bool) (ProcessList, error) {
	var err error

	// sql query
	const sqlstr = `SELECT` +
		`      pid,` +
		`      usename,` +
		`      datname,` +
		`      client_addr,` +
		`      CASE` +
		`      WHEN state = 'active'::text THEN` +
		`        EXTRACT(EPOCH FROM now() - query_start)` +
		`      WHEN state = 'idle in transcation'::text THEN` +
		`        EXTRACT(EPOCH FROM now() - xact_start)` +
		`      ELSE` +
		`        EXTRACT(EPOCH FROM now() - state_change)` +
		`      END AS duration,` +
		`      CASE` +
		`      WHEN state = 'active'::text THEN` +
		`        CASE` +
		`        WHEN query IS NOT NULL THEN` +
		`          btrim(` +
		`            regexp_replace(` +
		`              regexp_replace(` +
		`                substring(query,0,80),` +
		`                E'[\n\r\u2028]+', '', 'g'` +
		`              ),` +
		`              E'[ ]+', ' ', 'g'` +
		`            ),` +
		`          ' ')` +
		`        ELSE` +
		`          'No query'` +
		`        END` +
		`      ELSE` +
		`        'Inactive'` +
		`      END AS query,` +
		`      CASE` +
		`      WHEN waiting THEN` +
		`        'true'` +
		`      ELSE` +
		`        'false'` +
		`      END` +
		`    FROM pg_stat_activity` +
		`    WHERE query NOT ILIKE '%pg_stat_activity%'`

	res := ProcessList{
		Processes: nil,
		Inactive:  options["showInactive"],
	}
	// run query
	XOLog(sqlstr)
	q, err := db.Query(sqlstr)
	if err != nil {
		return res, err
	}
	defer q.Close()

	// load results
	for q.Next() {
		pl := Process{}

		// scan
		err = q.Scan(
			&pl.Pid,
			&pl.Usename,
			&pl.Datname,
			&pl.Client,
			&pl.Duration,
			&pl.Query,
			&pl.Waiting,
		)
		if err != nil {
			return res, err
		}

		res.Processes = append(res.Processes, pl)
	}

	return res, nil
}
